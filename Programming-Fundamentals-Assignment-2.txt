Q1:-
Statically Typed Language:
1. Data types of variables are determined and checked at **compile time**.
2. Variables must be explicitly declared with their data types before use.
3. Type checking ensures only compatible operations are performed on variables.
4. Types are fixed and cannot be changed during runtime.
5. Examples: Java, C, C++, Swift.

Dynamically Typed Language:
1. Data types of variables are determined and checked at **runtime** (during execution).
2. Variables do not require explicit type declarations; types are inferred from assigned values.
3. Offers flexibility but may lead to type-related errors during runtime.
4. Examples: Python, JavaScript, Ruby, PHP.

Strongly Typed Language:
1. Type safety is strictly enforced, and type conversions are not performed implicitly.
2. Data types are fixed and cannot be implicitly converted into other types without explicit typecasting.
3. Early detection of type-related errors during compilation.
4. Applies to both statically and dynamically typed languages.
5. Examples: Java, C#, Swift, Haskell.

Loosely Typed Language (Weakly Typed Language):
1. The type system is more flexible, allowing automatic type conversions.
2. Variables can change their data type without explicit typecasting.
3. May lead to unexpected results if not handled carefully.
4. Emphasizes ease of use over strict type safety.
5. Examples: JavaScript, PHP.

Java falls into the category of:
- A **statically typed** language because data types are checked at compile time.
- A **strongly typed** language because it enforces strict type safety and doesn't allow implicit type conversions.

################################################################################################################
Q2:-
1. Case Sensitive:
- Case sensitivity means that the programming language distinguishes between uppercase and lowercase characters in identifiers.
- Identifiers with different cases are treated as distinct entities.
- For example, in a case-sensitive language:
  - `variable` and `Variable` are considered two different variables.
  - `functionName` and `FunctionName` are considered two different function names.

*Example of Case Sensitive Programming Language:
- Python is a case-sensitive language. In Python, `variable` and `Variable` are treated as different variables.

2. Case Insensitive:
- Case insensitivity means that the programming language treats uppercase and lowercase characters in identifiers as equivalent.
- Identifiers written with different cases are considered the same entity.
- For example, in a case-insensitive language:
  - `variable` and `Variable` are considered the same variable.
  - `functionName` and `FunctionName` are considered the same function name.

*Example of Case Insensitive Programming Language:
- SQL (Structured Query Language) is case-insensitive for identifiers. In SQL, `SELECT`, `Select`, and `select` are all treated as the same keyword.

3. Case Sensitive-Insensitive (Partial Case Insensitive):
- Some programming languages exhibit partial case sensitivity, where the treatment of case sensitivity depends on specific contexts.
- For instance, the language may be case-sensitive for variable names but case-insensitive for keywords.
- In this scenario:
  - `variable` and `Variable` would be considered distinct variables.
  - `if`, `IF`, and `If` would be considered the same keyword.

*Example of Case Sensitive-Insensitive Programming Language:
- JavaScript is an example of a partially case-sensitive language. Variable names are case-sensitive, but JavaScript keywords like `if`, `for`, `while`, etc., are case-insensitive.

**Java in Relation to These Terms:
- Java is a **case-sensitive** programming language. It differentiates between uppercase and lowercase characters in identifiers.
- For example, `variable` and `Variable` would be considered two different variables in Java, and `if`, `IF`, and `If` would be treated as different keywords in Java.

##################################################################################################################
Q3:-
In Java, identity conversion is a type conversion where a value is explicitly or implicitly converted to its own type without any modification. It is a trivial conversion that ensures type compatibility, and no data loss or change in representation occurs during this process. Identity conversion is applied when the target type is the same as the source type, making the conversion unnecessary.

Two examples of identity conversion in Java:

*Example 1: Assigning a value to a variable of the same type:

***java

public class IdentityConversionExample1 {
    public static void main(String[] args) {
        int number = 42;
        int anotherNumber = number; // Identity conversion: Assigning 'number' to 'anotherNumber'
        System.out.println("Value of anotherNumber: " + anotherNumber); // Output: Value of anotherNumber: 42
    }
}

In this example, an integer variable `number` is assigned the value `42`. Then, `anotherNumber` is assigned the value of `number`, which is an example of identity conversion. Both `number` and `anotherNumber` are of the same type (`int`), so the conversion is not necessary. The value is directly copied from `number` to `anotherNumber`.

*Example 2: Passing an argument to a method with the same type parameter:

***java

public class IdentityConversionExample2 {
    public static void main(String[] args) {
        String message = "Hello, Java!";
        printMessage(message); // Identity conversion: Passing 'message' as an argument
    }

    public static void printMessage(String msg) {
        System.out.println("Message: " + msg); // Output: Message: Hello, Java!
    }
}


In this example, a `String` variable `message` is initialized with the value `"Hello, Java!"`. The `printMessage` method takes a `String` parameter `msg`, and we call this method, passing `message` as an argument. The argument passing is an example of identity conversion, as both the argument (`message`) and the parameter (`msg`) are of the same type (`String`). The conversion is not required, as the types match, and the value of `message` is directly passed to the method.

In both examples, identity conversion is utilized to ensure type compatibility without any change in the value or type representation. It demonstrates the efficiency and convenience of handling same-type conversions without the need for any actual conversion process.

#######################################################################################################################
Q4:-
Primitive widening conversion in Java is an automatic type conversion that occurs when a data value of a smaller primitive type is assigned to a variable of a larger primitive type. In this process, the value is widened to fit into the larger data type without any loss of data. Java performs primitive widening conversions implicitly, as they involve widening the range of values and, therefore, do not result in any data loss or precision issues.

The primitive data types in Java and their sizes, in increasing order of size, are as follows:

1. byte (1 byte)
2. short (2 bytes)
3. int (4 bytes)
4. long (8 bytes)
5. float (4 bytes)
6. double (8 bytes)

The implicit primitive widening conversions are as follows:

byte → short → int → long → float → double

Now, let's demonstrate primitive widening conversions with examples and diagrams:

*Example 1: byte to short

***java
public class PrimitiveWideningExample {
    public static void main(String[] args) {
        byte b = 100;
        short s = b; // Widening conversion: byte to short
        System.out.println("Value of s: " + s); // Output: Value of s: 100
    }
}


*Example 2: int to long

***java
public class PrimitiveWideningExample {
    public static void main(String[] args) {
        int num = 42;
        long bigNum = num; // Widening conversion: int to long
        System.out.println("Value of bigNum: " + bigNum); // Output: Value of bigNum: 42
    }
}


In both examples, we can observe the following:

1. The source variable (`b` in Example 1 and `num` in Example 2) has a smaller data type (byte and int, respectively).
2. The target variable (`s` in Example 1 and `bigNum` in Example 2) has a larger data type (short and long, respectively).
3. The assignment statements (`short s = b;` and `long bigNum = num;`) perform primitive widening conversions automatically.

*Diagrammatic Representation:
The diagrams below illustrate how primitive widening conversions work:

***
Example 1: byte to short
   byte (8 bits)   →   short (16 bits)
  ┌─────────────┐     ┌───────────────────┐
  │    100      │     │         100       │
  └─────────────┘     └───────────────────┘
       (b)                  (s)

Example 2: int to long
   int (32 bits)   →    long (64 bits)
  ┌─────────────┐      ┌───────────────────┐
  │     42      │      │         42        │
  └─────────────┘      └───────────────────┘
      (num)                (bigNum)


In Example 1, the byte value `100` is widened to a short without any loss of data. Similarly, in Example 2, the int value `42` is widened to a long without any data loss. These conversions ensure that the values fit safely into the larger data types without compromising precision.


